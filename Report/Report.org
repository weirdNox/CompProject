#+TITLE: Projeto de Computadores
#+SUBTITLE: Desenho de figuras arbitrárias usando um \acs{DAC} com o modo XY
#+AUTHOR: André Aragão e Gonçalo Santos
#+LANGUAGE: pt
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage[portuguese]{babel}
#+LATEX_HEADER: \usepackage{siunitx}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[section]{placeins}
#+LATEX_HEADER: \usepackage[printonlyused]{acronym}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}

* Introdução
Este projeto consiste no uso de um \ac{DAC} para efetuar o desenho de figuras arbitrárias com o modo XY
do osciloscópio (ou XYZ nos analógicos). Colocámos como primeira opção o [[https://www.microchip.com/wwwproducts/en/en541737][MCP4728]] visto que se tratava
de um \ac{DAC} mais rápido (menor tempo de asssentamento) do que o outro proposto nos trabalhos, da
/Texas Instruments/, apesar de termos menor resolução: 12 bits, ao invés dos 16bits do outro.

Este relatório está dividido em 2 secções principais:
- Diário de bordo :: Nesta secção apresentamos, de maneira geral, o trabalho desenvolvido e os problemas
     encontrados em cada dia de trabalho
- Detalhes técnicos :: Nesta secção são apresentados todos os detalhes técnicos do nosso projeto

* Diário de bordo
** [2018-12-14 Fri] Primeira aula prática laboratorial
Foi nesta aula que foram anunciados os projetos que tinham sido atribuídos a cada equipa, ficando a nossa
equipa com o *MCP4728*. Assim que soubemos qual era o nosso, começámos a ler cuidadosamente a /datasheet/
correspondente. Também aproveitámos para rever o funcionamento do [[https://en.wikipedia.org/wiki/I%25C2%25B2C][\ac{I2C}]], que é o protocolo de
comunicação usado pelo nosso conversor.

Ao fim de algum tempo, efetuámos a montagem cuidadosa do circuito pedido, assim como [[fig:Wiring][o seu desenho]] a
computador recorrendo ao programa [[http://fritzing.org/home/][Fritzing]]. Assim que a montagem foi aprovada pelo professor, escrevemos
um programa simples que fazia uma chamada a todos os endereços \ac{I2C} possíveis para termos a certeza
que estávamos a ter uma comunicação bem sucedida com o dispositivo.

#+NAME: fig:Wiring
#+CAPTION: Representação das ligações elétricas
[[file:Pictures/breadboard_setup.png]]

Não só descobrimos que a montagem tinha sido feita corretamente, uma vez que estávamos a receber um
\texttt{ACK} do MCP4728, mas também que o seu endereço não era o que vinha por defeito da fábrica -
\texttt{0x60} - mas sim \texttt{0x61} (este dispositivo tem os 3 \ac{LSB} de endereço configuráveis,
guardados numa EEPROM).

** [2018-12-20 Thu] Trabalho em casa
Em casa, aproveitámos para ler melhor a /datasheet/ e vimos que havia um comando /General Call Read
Address/, que permitia obter o endereço do \acs{DAC} sem fazer /polling/ de todos. Apesar de já não ser
necessário, implementámos de qualquer maneira como desafio.

** [2018-12-21 Fri] Segunda aula prática laboratorial
Neste dia, implementámos o comando /Write \acs{I2C} Address Bits/ com sucesso, conseguindo mudar o
endereço de \texttt{0x61} para \texttt{0x60}.

Também tentámos implementar o comando /Fast Write/ para definir as tensões analógicas nas 4 saídas do
MCP4728. Infelizmente, passámos a maior parte da aula sem obter grande sucesso, visto que não conseguimos
ler os valores corretamente.

Chegando a casa, e sem nenhuma alteração quer a nível de montagem, quer a nível de código, verificámos
que estava a funcionar o corretamente, pelo que consideramos que o multímetro de bancada no laboratório
não se encontrava a funcionar corretamente. Após o correto funcionamento, experimentamos variar a tensão
entre 2 valores pré-definidos, e o teste foi um sucesso.

** [2018-12-22 Sat] Temporizações e início de testes modo XY
O passo seguinte foi tentar enviar vários sinais consecutivos com o comando /Multi-Write/.

Depois de algumas iterações do programa, de maneira a resolver problemas que íamos encontrando, acabámos
por usar \SI{100}{\mega\hertz} como frequência de \acs{I2C} (/Fast Mode Plus/). As resistências de
pull-up foram alteradas para um valor adequado: \SI{4.7}{\kilo\ohm}. Esta frequência é a máxima suportada
pelo PIC32.

Posteriormente, apercebemo-nos que seria útil medirmos o tempo de transferência do comando, para termos
ideia dos limites que teríamos nas nossas animações. Todas as medições estão [[id:f0c8fa30-7070-4227-afd7-e13092c0d150][explicadas na secção de
detalhes técnicos]].

Finalmente, iniciámos a exploração do modo XY. Depois de testarmos o envio de 1 e de 2 pontos com
sucesso, testamos a transmissão de uma circuferência. Para isso, utilizámos [[id:9086e8c2-73b9-4fc9-b209-bce4e496085a][estes scripts]] para gerar
$100$ pontos da função $\sin$. Desfazando X e o Y \ang{90}, a circunferência foi desenhada com sucesso.

** [2018-12-23 Sun] Testes extensivos do modo XY e início da aplicação de controlo
Inicialmente, começámos por animar o desenho ao longo do tempo, alternando entre 2 circunferências de
raios diferentes a cada \SI{5}{\second}.

Como próximo passo decidimos fazer uma letra, ainda manualmente. Desenhamos no /software Inkscape/ a
letra =C=, num documento quadrado de 4096 pontos de lado, e amostrámos 20 pontos, definindo as suas
coordenadas X e Y. O teste foi um sucesso.

Desenhar as formas manualmente, ou seja, com recurso a papel e lápis, não era viável visto que seria
extremamente trabalhoso, pelo que ponderamos duas opções:

- Opção 1 :: Desenho na grelha de um ficheiro /Excel/ e exportando para /arrays/ com o uso de macros ou
             de um programa auxiliar que lesse =.csv=

- Opção 2 :: Criação de um programa para o computador em C, com interface gráfica, para que, com auxílio
             de uma grelha, o utilizador possa desenhar a forma geométrica que quiser, sendo esta
             exportada num formato fácil de importar no programa do MCU.

Optámos pela *opção 2* uma vez que:
- Linguagem C já era familiar
- Tinha maior flexibilidade para implementar várias /features/ que tínhamos em mente
- Poderia ser extendido facilmente de maneira a fazer *comunicação direta* (série) com o PIC32 e enviar
  as animações sem recompilação ou /upload/ de programas novos

A dificuldade principal era criar um programa com interface gráfica de raiz. No entanto, como já tínhamos
investigado sobre esse tópico anteriormente, decidimos usar as bibliotecas [[https://www.glfw.org/][GLFW]] (+ [[https://github.com/raysan5/raylib/blob/master/src/rglfw.c][rglfw]] para facilitar a
compilação), [[https://github.com/skaslev/gl3w][gl3w]] e [[https://github.com/ocornut/imgui][Dear ImGui]], que facilitaram bastante esse processo, apesar de serem todas muito
/lightweight/ em comparação com as alternativas (tais como Qt ou GTK).

No final da manhã, mesmo sem nunca ter trabalhado com as bibliotecas anteriormente, já tínhamos um
programa com funcionalidade mínima: permitia o desenho de uma /frame/ e, com o /click/ de um botão, era
possível exportá-la para um ficheiro /header/ em C.

** TODO [2018-12-28 Fri] Melhoramento aplicação de controlo
# Mandar isto para a parte técnica?
Adicionámos as seguintes funcionadidades:
- Possibilidade de desenhar várias /frames/ graficamente e de alterar o tempo de cada frame para valores
  arbitrários.
- Possibilidade de visualizar a frame anterior, para mais fácil reprodução de uma /imagem animada/. Esta
  técnica é designada por /onion skinning/. Os pontos da frame anterior aparecem com uma cor diferente,
  mais neutra, para melhor distinção.
- Uma linha vermelha, que percorre todos os pontos pela ordem em que são desenhados, de maneira a que
  seja evidente saltos visualizados no osciloscópio. Esta funcionalidade permite prever linhas
  indesejadas.
- Possibilidade de optimizar o caminho, através do algoritmo /nearest neighbour/. Esta optimização tem
  sempre de ser averiguada visualmente pelo utilizador, visto que pode até prejudicar o caminho
  percorrido. Destina-se a tentar reduzir as linhas indesejadas resultantes de saltos.

A nível de hardware mudámos os cabos para uns de tamanho adaptado, para facilidade de transporte e
redução de possíveis perdas. Verificamos que estes cabos não ficavam tão bem presos aos pinos fêmea do
MCU, fazendo por vezes mau contacto. Voltámos ao /setup/ inicial.

** TODO [2019-01-03 Thu] Implementação de modo Z e protocolo de comunicação
Começámos por tentar implementar uma maneira de eliminar as linhas visualizadas entre blocos não
consecutivos. Esta funcionalidade só será útil para osciloscópios com entrada Z.

Medimos o tempo de assentamento da alteração de um valor analógico, e verificámos que o pior valor medido
coincide com o valor máximo fornecido pela /datasheet/: \SI{6.4}{\micro\second}.

# A descrição do modo Z estava incorreta! Para além disso, talvez devesse ser na parte técnica?

O passo seguinte foi definirmos o protocolo de comunicação, e, consequentemente, implementá-lo. Todo o
protocolo é [[id:ffbc339b-a6af-4465-a5f4-9419ae657372][explicado na secção de detalhes técnicos]].

# Mandar para detalhes técnicos
Antes de implementar o protocolo, verificámos a /endianess/ do computador e do PIC32. Ambos reveleram ser
/little-endian/. Para além disso, resolvemos adicionar uma cláusula de alerta para o compilador, visto
que todo o programa só está feito para funcionar quando ambas as partes usam /little-endian/.

** TODO Dias restantes....

* Detalhes técnicos
** TODO Temporizações
:PROPERTIES:
:ID:       f0c8fa30-7070-4227-afd7-e13092c0d150
:END:
#+NAME:   fig:Timings
#+CAPTION: Diagrama ilustrativo dos tempos de envio
[[file:Pictures/timings_diagram.png]]

Frequência \ac{I2C}, /Fast Mode Plus/ = 1Mhz
Frequência \ac{I2C} efetivamente medida = 1/(1.1us) Hz = 910kHz
Tempo de transferência de um byte + ACK = (8+1) / f = 9.5us
Pausas encontradas:
- p1, entre o endereço e os bytes de dados(significativamente maior que as pausas a seguir mencionadas): 6.9us
- p2, entre bytes+ACK (5 pausas): 2.66us
- p3, entre o 6 byte+ACK de dados e o STOP: 7.88us
- p4, entre o STOP e o posterior START do próximo envio: 8.5us
Assim, desprezando o tempo do START e STOP, o cáculo do período é dado por (7*t(byte+ack)+p1+5*p2+p3) = 95us.

A medição efetuada no osciloscópio, recorrendo aos cursores, confirmou os 95 us. Para questões de código
aproximamos este valor a 100us, dando assim uma margem para possíveis atrasados (não nos podemos esquecer
que estamos a correr várias funções).

** TODO Aplicação de controlo
** TODO Protocolo de comunicação com o PIC32 (sobre UART)
:PROPERTIES:
:ID:       ffbc339b-a6af-4465-a5f4-9419ae657372
:END:
* Conclusão
Este trabalho levou ao aprofundamento do nosso conhecimento em vários domínios, nomeadamente:
- Familizarização com a ferramente git, com recurso ao Gitlab
- Domínio da linguagem LaTeX
- Familiarização com a leitura de /datasheets/
- Aprofundamento do conhecimento do microcontrolador PIC32
- Aprofundamento do conhecimento do protocolo de comunicação \ac{I2C}
- Integração de bibliotecas, mais concretamente, a biblioteca Dear ImGUI
- Aprofundamento do conhecimento de transferência de dados, assim como os seus problemas: /framing/,
  /data loss/, etc

Inicialmente tivemos algumas pequenas complicações, como a falha na leitura dos valores durante toda a
segunda aula prática laboratorial, mas rapidamente foram solucionadas. O problema mais grave foi sem
dúvida alguma termos queimado a placa fornecida pela faculdade, devido a termos ligado um transformador
que tinhamos connosco de 12V. Apesar da inscrição referente ao /jack DC/ dizer /15V MAX!/, o /jumper/
azul da placa responsável pela seleção do /Power Select/ encontrava-se no modo /Bypass/, o que, através
da nossa pesquisa, indica que o PIC32 é diretamente alimentado pela fonte ligada ao /jack DC/. Como o
PIC32 apenas suporta 6V diretamente, acreditamos que o chip queimou. Foi evidente que algo errado
aconteceu visto que o /IC3/ da placa ficou "furado". No mesmo dia adquirimos outra placa igual.

Consideramos que este trabalho, enquanto futuros engenheiros, representou um processo de aprendizagem
significativo. Tivemos a oportunidade de abordar conceitos multidisciplinares, nomeadamente de unidades
curriculares como Programação, Informação e Comunicação e, como não poderia deixar de ser, Computadores.

* Apêndices                                                                                    :ignore_nested:
#+BEGIN_EXPORT latex
\appendix
\section*{Apêndices}
\addcontentsline{toc}{section}{Apêndices}
\renewcommand{\thesubsection}{\Alph{subsection}}
#+END_EXPORT
** Criação do /array/ com os valores sinusoidais
:PROPERTIES:
:ID:       9086e8c2-73b9-4fc9-b209-bce4e496085a
:END:
O próximo excerto de código gera 100 valores da função $2048 + 2047 \sin t$, com $t \in [0, 2\pi[$, e imprime
um /array/ em linguagem C do tipo =uint16_t[]= com esses valores.
#+BEGIN_SRC matlab :results output :exports both :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 BigSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 2047*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 BigSin[] = {
         2048, 2177, 2305, 2432, 2557, 2681, 2802, 2920, 3034, 3145,
         3251, 3353, 3449, 3540, 3625, 3704, 3776, 3842, 3900, 3951,
         3995, 4031, 4059, 4079, 4091, 4095, 4091, 4079, 4059, 4031,
         3995, 3951, 3900, 3842, 3776, 3704, 3625, 3540, 3449, 3353,
         3251, 3145, 3034, 2920, 2802, 2681, 2557, 2432, 2305, 2177,
         2048, 1919, 1791, 1664, 1539, 1415, 1294, 1176, 1062, 951,
         845,  743,  647,  556,  471,  392,  320,  254,  196,  145,
         101,  65,   37,   17,   5,    1,    5,    17,   37,   65,
         101,  145,  196,  254,  320,  392,  471,  556,  647,  743,
         845,  951,  1062, 1176, 1294, 1415, 1539, 1664, 1791, 1919,
     };"
#+end_example

Usámos o mesmo processo para gerar os valores para uma sinusoidal mais pequena, com a fórmula
$2048 + 1024 \sin t$.
#+BEGIN_SRC matlab :results output :exports none :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 SmallSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 1024*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 SmallSin[] = {
         2048, 2112, 2176, 2240, 2303, 2364, 2425, 2484, 2541, 2597,
         2650, 2701, 2749, 2794, 2837, 2876, 2913, 2945, 2975, 3000,
         3022, 3040, 3054, 3064, 3070, 3072, 3070, 3064, 3054, 3040,
         3022, 3000, 2975, 2945, 2913, 2876, 2837, 2794, 2749, 2701,
         2650, 2597, 2541, 2484, 2425, 2364, 2303, 2240, 2176, 2112,
         2048, 1984, 1920, 1856, 1793, 1732, 1671, 1612, 1555, 1499,
         1446, 1395, 1347, 1302, 1259, 1220, 1183, 1151, 1121, 1096,
         1074, 1056, 1042, 1032, 1026, 1024, 1026, 1032, 1042, 1056,
         1074, 1096, 1121, 1151, 1183, 1220, 1259, 1302, 1347, 1395,
         1446, 1499, 1555, 1612, 1671, 1732, 1793, 1856, 1920, 1984,
     };"
#+end_example

** Acrónimos
#+BEGIN_EXPORT latex
\begin{acronym}
  \acro{DAC}{Digital-to-Analog Converter}
  \acro{I2C}[I\textsuperscript{2}C]{Inter-Integrated Circuit}
  \acro{LSB}{bits menos significativos}
\end{acronym}
#+END_EXPORT
