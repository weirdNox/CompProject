#+TITLE: Projeto de Computadores
#+SUBTITLE: Desenho de figuras arbitrárias usando um \acs{DAC} com o modo XY
#+AUTHOR: André Aragão e Gonçalo Santos
#+LANGUAGE: pt
#+LATEX_HEADER: \usepackage[margin=.7in]{geometry}
#+LATEX_HEADER: \usepackage[portuguese]{babel}
#+LATEX_HEADER: \usepackage[binary-units]{siunitx}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[section]{placeins}
#+LATEX_HEADER: \usepackage[printonlyused]{acronym}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}

#+LATEX_HEADER: \newcommand{\ordMas}{\textsuperscript{\b{o}}}
#+LATEX_HEADER: \newcommand{\ordFem}{\textsuperscript{\b{a}}}
#+LATEX_HEADER: \makeatletter\newcommand{\nolisttopbreak}{\vspace{\topsep}\nobreak\@afterheading}\makeatother

* Introdução
Este projeto consiste no uso de um \ac{DAC} para efetuar o desenho de figuras arbitrárias com o modo XY
do osciloscópio (ou XYZ nos analógicos). A escolha do [[https://www.microchip.com/wwwproducts/en/en541737][MCP4728]], em detrimento
do outro \ac{DAC} proposto prendeu-se ao facto de este ser mais rápido (menor tempo de asssentamento), apesar de term menor resolução: 
\SI{12}{\bit}, ao invés dos \SI{16}{\bit} do \ac{DAC} da /Texas Instruments/.

Inicialmente, a ideia era fazer um gerador de sinais com os sinais clássicos, tais como ondas
sinusoidais, quadradas e triangulares, com as propriedades ajustáveis, e ainda, caso houvesse tempo, um
gerador de sinais arbitrário, onde o utilizador pode desenhar a forma de onda que quiser.

No entanto, depois de lermos a /datasheet/ do MCP4728, vimos que o resultado não seria muito
satisfatório, uma vez que a tecnologia \ac{I2C} não é a mais indicada para este tipo de funcionalidade, e
o tempo de assentamento do \ac{DAC}, ainda que incrivelmente baixo para algumas aplicações, resultaria
numas ondas não muito suaves ou então de muito baixa frequência.

Desanimados com a impossibilidade de executar a nossa ideia inicial, lembrámo-nos de ver algumas pessoas a desenhar imagens em osciloscópios. Depois
de pensar no assunto, apercebemo-nos que seria a aplicação ideal para um projeto destes, uma vez que, no
modo XY, o tempo de assentamento era suficientemente baixo para não se notarem as transições dos saltos
em demasia.

Propusémo-nos então a fazer um sistema de desenho de animações onde o utilizador pode desenhar várias
frames de tempo regulável e ver uma representação fiel no osciloscópio do que desenhou.

* Configuração inicial
A primeira coisa que fizemos foi ler cuidadosamente a /datasheet/ correspondente ao MCP4728. Também
revimos o funcionamento do [[https://en.wikipedia.org/wiki/I%25C2%25B2C][\ac{I2C}]], que é o protocolo de comunicação usado pelo conversor.

Efetuámos a montagem cuidadosa do circuito pedido, assim como [[fig:Wiring][o seu desenho]] a computador recorrendo ao
programa [[http://fritzing.org/home/][Fritzing]], e de seguida escrevemos um programa simples que fazia uma chamada a todos os endereços
\ac{I2C} possíveis para termos a certeza que estávamos a ter uma comunicação bem sucedida com o
dispositivo.

#+NAME: fig:Wiring
#+CAPTION: Representação das ligações elétricas
[[file:Pictures/breadboard_setup.png]]

Não só descobrimos que a montagem tinha sido feita corretamente, uma vez que estávamos a receber um
\texttt{ACK} do MCP4728, mas também que o seu endereço não era o que vinha por defeito da fábrica -
\texttt{0x60} - mas sim \texttt{0x61} (este dispositivo tem os 3 \ac{LSB} de endereço configuráveis,
guardados numa EEPROM).

Verificámos na /datasheet/ que existe um comando [[id:4425274b-aab9-4c6e-a1b8-babebde948b2][General Call Read Address]], que permite obter o endereço
do \ac{DAC} sem fazer /polling/ de todos os endereços. Apesar de já não ser necessário, implementámo-lo
de qualquer maneira como desafio.

A implementação do comando [[id:4425274b-aab9-4c6e-a1b8-babebde948b2][Write \ac{I2C} Address Bits]] foi bem sucedida, conseguindo mudar o endereço
de \texttt{0x61} para \texttt{0x60}.

Usando o comando [[id:56b96a2d-1623-49f4-9d64-b22e747d8ec1][Fast Write]], conseguimos definir a tensão de um dos outputs para um valor pretendido e
definir os outros como resistências à massa.

Considerámos que nos encontrávamos na posição de iniciar o envio de pontos e visualização no
osciloscópio, no modo XY. Depois de testarmos o envio de 1 e 2 pontos com sucesso, testámos a transmissão
de uma circuferência. Para isso, utilizámos [[id:9086e8c2-73b9-4fc9-b209-bce4e496085a][estes scripts]] para gerar $100$ pontos da função $\sin$.
Desfazando X e o Y \SI{90}{\degree}, a circunferência foi desenhada com sucesso.

Inicialmente, começámos por animar o desenho ao longo do tempo, alternando entre 2 circunferências de
raios diferentes a cada \SI{5}{\second}. Depois decidimos fazer uma letra, ainda manualmente. Desenhámos no /software Inkscape/ a
letra =C=, num documento quadrado de 4096 pontos de lado, e amostrámos 20 pontos, definindo as suas
coordenadas X e Y, e escrevendo num array do programa que corria no MCU. Mais uma vez, o teste foi um
sucesso.

A partir deste ponto considerámos que já tínhamos uma base de trabalho razoável e decidimos efetuar a
medição rigorosa do tempo de envio de cada pacote, com o objetivo de que tudo o que fizessemos daqui para
a frente tomasse partido de toda a capacidade do PIC32 e do MCP4728.

* Detalhes técnicos
** Comandos utilizados e configuração \acs{I2C}
*** Frequência de funcionamento
Tendo em conta que queríamos desenhar uma frame o mais rapidamente possível, acabámos por usar
\SI{1}{\mega\hertz} como frequência de \ac{I2C} (/Fast Mode Plus/). As resistências de /pull-up/ foram
alteradas para um valor adequado: \SI{4.7}{\kilo\ohm}.

Enquanto que o \ac{DAC} suportava uma frequência ainda maior (/High Speed Mode/), esta era a máxima
suportada pelo PIC32.

*** General Call Read Address e Write \acs{I2C} Address Bits
:PROPERTIES:
:ID:       4425274b-aab9-4c6e-a1b8-babebde948b2
:END:
Estes comandos merecem atenção especial pois não consistem apenas em correr um comando.

#+NAME: fig:GeneralCallReadAddr
#+CAPTION: Diagrama do comando /General Call Read Address/, retirado da /datasheet/ do MCP4728
[[file:Pictures/generalCallReadAddr.png]]

Como podemos ver no [[fig:GeneralCallReadAddr][diagrama]] para o comando /General Call Read Address/ (e semelhantemente para o /Write
Address Bits/), é preciso que o =LDAC= tenha um \ac{FE} entre o 8\ordMas e o 9\ordMas pulso de relógio.

Obter essa \ac{FE} não foi trivial, mas depois de ler a /datasheet/ do PIC32, vimos que o bit TBF é
anulado precisamente no instante que queremos. Para conseguirmos reagir rapidamente, definimos um /timer/
de \SI{500}{\kilo\hertz} que verificava esse bit e colocava o LDAC a 0 no instante correto (como está
feito no ficheiro =AddrReadWrite.cpp=).

*** Sequential Write
Este comando é usado na inicialização do programa para definir as definições das 4 saídas do \ac{DAC}.

Como 2 saídas não são usadas, são desativadas e funcionam como uma resistência (de \SI{100}{\kilo\ohm}
com PD = 10) à massa. Nesse modo de /power-down/, consomem consideravelmente menos corrente.

*** Fast Write
:PROPERTIES:
:ID:       56b96a2d-1623-49f4-9d64-b22e747d8ec1
:END:
Este comando permite atualizar os registos internos de *todas* as saídas do \ac{DAC}. As saídas em si são
atualizadas quando o =LDAC= é (ou passa para) 0.

Apesar de enviar menos informação/saída, como este comando envia informação de todas as saídas, precisa
de $1+8$ bytes; por isso, não foi utilizado por nós na versão final.

*** Multi-Write
Este é o comando mais usado no programa. É o que usamos para definir as tensões das saídas X e Y para
cada ponto de cada frame. Como só atua nas 2 saídas relevantes, apenas precisa de $1 + 6$ bytes.

*** Select power-down bits
Este comando é usado quando queremos desligar todas as saídas.

** Temporizações
:PROPERTIES:
:ID:       f0c8fa30-7070-4227-afd7-e13092c0d150
:END:
*** Medição da frequência
- Frequência \ac{I2C} (/Fast Mode Plus/): \SI{1}{\mega\hertz}
- Frequência \ac{I2C} medida: $\frac{1}{\SI{1.1}{\micro\second}} \approx \SI{910}{\kilo\hertz}$

*** Tempo de envio do Multi-Write
\[ t_{byte} + t_{ack} = \SI{9.5}{\micro\second} \]

#+NAME:   fig:Timings
#+CAPTION: Diagrama ilustrativo do tempo de envio do comando, =START= a verde e =STOP= a vermelho
[[file:Pictures/timings_diagram.png]]

Duração das pausas:\nolisttopbreak
- $p_1 = \SI{6.9}{\micro\second}$
- $p_2 = \SI{2.66}{\micro\second}$
- $p_3 = \SI{7.88}{\micro\second}$
- $p_4 = \SI{8.5}{\micro\second}$

Assim, desprezando o tempo do =START= e do =STOP=, o tempo de transmissão de cada comando é dado por
$7 (t_{byte}+t_{ack})+p_1+5 p_2+ p_3) = \SI{95}{\micro\second}$. A medição efetuada no osciloscópio, recorrendo aos
cursores, confirmou esse valor.

No programa, aproximámos esse tempo por \SI{100}{\micro\second}, e considerámos $p_4$ desprezável.

*** Limitação do número de pontos por frame
O resultado obtido na secção anterior permite-nos derivar um limite para o número de pontos máximo por
frame.

A nossa decisão foi que as animações /nunca/ deviam correr abaixo de 30 FPS. Sendo assim, temos um tempo
máximo de \SI{30}{\milli\second} por cada frame. Uma vez que cada ponto demora \SI{100}{\micro\second} a ser
transmitido, então podemos ter, /no máximo/, 300 pontos por frame.

Este limite tem outras implicações práticas:
- Nunca precisamos de alocação dinâmica pois conhecemos o limite superior do tamanho das animações.
  Podemos simplesmente alocar um array com o tamanho máximo e preenchê-lo à medida que o utilizador
  desenha.
- A grelha de desenho deve ter pontos suficientes para se poder desenhar com detalhe, mas também não deve
  ter pontos tão pequenos que um arrastar do rato preencha 200 ou 300 pontos de uma só vez. Usámos um
  tamanho para a grelha de 64 por 64 e vimos que esse tamanho satisfazia ambas as condições.
  - Este tamanho de grelha implica uma redução de precisão dos 12 bits que o \ac{DAC} fornece. Isto foi
    usado a nosso favor no [[id:6e5bb395-210e-4a84-81bf-a047e12a68e9][protocolo de comunicação]].

** Aplicação de controlo
Desenhar as formas manualmente, ou seja, com recurso a papel e lápis, não era viável visto que seria
extremamente trabalhoso, pelo que ponderámos duas opções para otimizar o processo:

- Opção 1 :: Desenho na grelha de um ficheiro /Excel/ e exportando para /arrays/ com o uso de macros ou
             de um programa auxiliar que lesse =.csv=

- Opção 2 :: Criação de um programa para o computador em C, com interface gráfica, para que, com auxílio
             de uma grelha, o utilizador possa desenhar a forma geométrica que quiser, sendo esta
             exportada num formato fácil de importar no programa do MCU.

Optámos pela *opção 2* uma vez que:
- Linguagem C já era familiar
- Tinha maior flexibilidade para implementar várias /features/ que tínhamos em mente
- Poderia ser extendido facilmente de maneira a fazer *comunicação direta* (UART) com o PIC32 e enviar as
  animações para o MCU sem ter de recompilar e fazer upload

A dificuldade principal era criar um programa com interface gráfica de raiz. No entanto, como já tínhamos
investigado sobre esse tópico anteriormente, decidimos usar as bibliotecas [[https://www.glfw.org/][GLFW]] (+ [[https://github.com/raysan5/raylib/blob/master/src/rglfw.c][rglfw]] para facilitar a
compilação), [[https://github.com/skaslev/gl3w][gl3w]] e [[https://github.com/ocornut/imgui][Dear ImGui]], que facilitaram bastante esse processo, apesar de serem todas muito
/lightweight/ em comparação com as alternativas (tais como Qt ou GTK).

Aproveitamos para referir o facto da biblioteca de interface gráfica, /Dear ImGui/, não ser como as mais
conhecidas, pois em vez de ser /Retained Mode/, é, como o nome indica, /Immediate Mode GUI/. Este
paradigma foi popularizado por [[https://caseymuratori.com/about][Casey Muratori]], criador da série educativa [[https://handmadehero.org/][Handmade Hero]].

Numa /IMGUI/, o código do utilizador tem a maior parte dos dados necessários para renderizar a interface, e
a interface é quase completamente reconstruída a 60FPS, enquanto que nas /RMGUIs/ os dados estão
guardados nas estruturas das próprias bibliotecas.

Assim sendo, é muito mais fácil criar interfaces altamente dinâmicas, onde tudo pode ser alterado de uma
frame para a outra. Esta biblioteca em específico é também muito extensível, o que foi uma vantagem pois
o /widget/ da grelha de desenho foi feito especialmente para este projeto.

A aplicação de controlo, após finalizada, possui as seguintes features:\nolisttopbreak
- Possibilidade de desenhar até 10 /frames/ graficamente e de alterar a duração de cada frame para
  valores arbitrários.
- Possibilidade de visualizar a frame anterior, para mais fácil criação de uma /imagem animada/. Esta
  técnica é designada por /onion skinning/. Os pontos da frame anterior aparecem com uma cor diferente,
  mais neutra, para distinção.
- Uma linha vermelha, que percorre todos os pontos pela ordem em que são desenhados, de maneira a que
  seja evidente saltos visualizados no osciloscópio. Esta funcionalidade permite prever linhas
  indesejadas.
- Possibilidade de optimizar o caminho, através do algoritmo /nearest neighbour/. Esta optimização tem
  sempre de ser averiguada visualmente pelo utilizador, visto que pode até prejudicar o caminho
  percorrido. Destina-se a tentar reduzir as linhas indesejadas resultantes de saltos.
- Possibilidade de guardar/carregar animações para/de ficheiros (formato binário)

Para além destas features, tem ainda exportação de animações quer copiando um array em C para o
/clipboard/ quer [[id:6e5bb395-210e-4a84-81bf-a047e12a68e9][diretamente para o PIC32 através de um protocolo binário]].

** TODO Protocolo de comunicação com o PIC32 (sobre UART)
:PROPERTIES:
:ID:       6e5bb395-210e-4a84-81bf-a047e12a68e9
:END:
Antes de implementar o protocolo, verificámos a /endianess/ do computador e do PIC32. Ambos reveleram ser
/little-endian/. Para além disso, resolvemos adicionar uma cláusula de alerta para o compilador, visto
que todo o programa só está feito para funcionar quando ambas as partes usam /little-endian/.

O envio de dados em /plain text/ era uma opção demasiado dispendiosa - visto que cada carater requer a utilização de um byte,
pelo que começamos por procurar soluções mais eficientes. Deparamo-nos com este [[https://www.embeddedrelated.com/showarticle/113.php][artigo]],
que achamos muito útil. Foi ao ler este artigo que tivemos o primeiro contacto com o algoritmo /COBS/. Podemos resumir o algoritmo como cada bloco 
que termine com o delimitador escolhido é substituído por um bloco que começa com o tamanho do próprio bloco seguido dos dados, e o pacote final termina 
com o delimitador. A sequência de operações é a seguinte:
(1) Ao analisar a sequência, começamos por verificar se o primeiro valor é a /escape sequence/, inicializando o tamanho a escrever a /1/
(2) Caso não hajam mais dados a ler, escrevemos a /escape sequence/
(3) Caso seja a /escape sequence/, escrevemos logo 01 e voltamos ao passo (1)
(4) Caso não seja, incrementamos o tamanho a escrever em 1 unidades
(5) Continuamos até encontrar a /escape sequence/, e aí escrevemos o tamanho seguido da sequência de dados lida diferente da /escape sequence/
Assim, a sequência 07 09 00 01 00 00 02 03 04 05 06 00 18 22 passaria a 03 07 09 02 01 01 06 02 03 04 05 06 03 18 22 00.
No caso da nossa implementação adaptada, o valor delimitador aparece no início (e não no fim do pacote, como na implementação original do /COBS/).

* Conclusão
Este trabalho levou ao aprofundamento do nosso conhecimento em vários domínios, nomeadamente:
- Familizarização com a ferramenta git, com recurso ao Gitlab
- Domínio da linguagem LaTeX
- Familiarização com a leitura de /datasheets/
- Aprofundamento do conhecimento do microcontrolador PIC32
- Aprofundamento do conhecimento do protocolo de comunicação \ac{I2C}
- Integração de bibliotecas, mais concretamente, a biblioteca Dear ImGUI
- Aprofundamento do conhecimento de transferência de dados, assim como os seus problemas: /framing/,
  /data loss/, etc
- Desenvolvimento de protocolo de comunicação binário adaptado, baseado em /COBS/
- Aprofundamento de resolução de problemas de colisão, relativamente ao desenvolvimento do jogo /Pong/

Inicialmente tivemos algumas pequenas complicações, como a falha na leitura dos valores durante toda a
segunda aula prática laboratorial, mas rapidamente foram solucionadas. O problema mais grave foi sem
dúvida alguma termos queimado a placa fornecida pela faculdade, devido a termos ligado um transformador
que tinhamos connosco de 12V. Apesar da inscrição referente ao /jack DC/ dizer /15V MAX!/, o /jumper/
azul da placa responsável pela seleção do /Power Select/ encontrava-se no modo /Bypass/, o que, através
da nossa pesquisa, indica que o PIC32 é diretamente alimentado pela fonte ligada ao /jack DC/. Como o
PIC32 apenas suporta 6V diretamente, acreditamos que o chip queimou. Foi evidente que algo errado
aconteceu visto que o /IC3/ da placa ficou "furado". No mesmo dia adquirimos outra placa igual.

Consideramos que este trabalho, enquanto futuros engenheiros, representou um processo de aprendizagem
significativo. Tivemos a oportunidade de abordar conceitos multidisciplinares, nomeadamente de unidades
curriculares como Programação, Informação e Comunicação e, como não poderia deixar de ser, Computadores.

* Apêndices                                                                                    :ignore_nested:
#+BEGIN_EXPORT latex
\appendix
\section*{Apêndices}
\addcontentsline{toc}{section}{Apêndices}
\renewcommand{\thesubsection}{\Alph{subsection}}
#+END_EXPORT
** Criação do /array/ com os valores sinusoidais
:PROPERTIES:
:ID:       9086e8c2-73b9-4fc9-b209-bce4e496085a
:END:
O próximo excerto de código gera 100 valores da função $2048 + 2047 \sin t$, com $t \in [0, 2\pi[$, e imprime
um /array/ em linguagem C do tipo =uint16_t[]= com esses valores.
#+BEGIN_SRC matlab :results output :exports both :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 BigSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 2047*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 BigSin[] = {
         2048, 2177, 2305, 2432, 2557, 2681, 2802, 2920, 3034, 3145,
         3251, 3353, 3449, 3540, 3625, 3704, 3776, 3842, 3900, 3951,
         3995, 4031, 4059, 4079, 4091, 4095, 4091, 4079, 4059, 4031,
         3995, 3951, 3900, 3842, 3776, 3704, 3625, 3540, 3449, 3353,
         3251, 3145, 3034, 2920, 2802, 2681, 2557, 2432, 2305, 2177,
         2048, 1919, 1791, 1664, 1539, 1415, 1294, 1176, 1062, 951,
         845,  743,  647,  556,  471,  392,  320,  254,  196,  145,
         101,  65,   37,   17,   5,    1,    5,    17,   37,   65,
         101,  145,  196,  254,  320,  392,  471,  556,  647,  743,
         845,  951,  1062, 1176, 1294, 1415, 1539, 1664, 1791, 1919,
     };"
#+end_example

Usámos o mesmo processo para gerar os valores para uma sinusoidal mais pequena, com a fórmula
$2048 + 1024 \sin t$.
#+BEGIN_SRC matlab :results output :exports none :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 SmallSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 1024*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 SmallSin[] = {
         2048, 2112, 2176, 2240, 2303, 2364, 2425, 2484, 2541, 2597,
         2650, 2701, 2749, 2794, 2837, 2876, 2913, 2945, 2975, 3000,
         3022, 3040, 3054, 3064, 3070, 3072, 3070, 3064, 3054, 3040,
         3022, 3000, 2975, 2945, 2913, 2876, 2837, 2794, 2749, 2701,
         2650, 2597, 2541, 2484, 2425, 2364, 2303, 2240, 2176, 2112,
         2048, 1984, 1920, 1856, 1793, 1732, 1671, 1612, 1555, 1499,
         1446, 1395, 1347, 1302, 1259, 1220, 1183, 1151, 1121, 1096,
         1074, 1056, 1042, 1032, 1026, 1024, 1026, 1032, 1042, 1056,
         1074, 1096, 1121, 1151, 1183, 1220, 1259, 1302, 1347, 1395,
         1446, 1499, 1555, 1612, 1671, 1732, 1793, 1856, 1920, 1984,
     };"
#+end_example

** Acrónimos
#+BEGIN_EXPORT latex
\begin{acronym}
  \acro{DAC}{Digital-to-Analog Converter}
  \acro{FE}{falling edge}
  \acro{I2C}[\texorpdfstring{I\textsuperscript{2}C}{I2C}]{Inter-Integrated Circuit}
  \acro{LSB}{bits menos significativos}
\end{acronym}
#+END_EXPORT
