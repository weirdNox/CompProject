#+TITLE: Projeto de Computadores
#+SUBTITLE: Desenho de figuras arbitrárias usando um \acs{DAC} com o modo XY
#+AUTHOR: André Aragão e Gonçalo Santos
#+LANGUAGE: pt
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage[portuguese]{babel}
#+LATEX_HEADER: \usepackage[binary-units]{siunitx}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[section]{placeins}
#+LATEX_HEADER: \usepackage[printonlyused]{acronym}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}

#+LATEX_HEADER: \newcommand{\ordMas}{\textsuperscript{\b{o}}}
#+LATEX_HEADER: \newcommand{\ordFem}{\textsuperscript{\b{a}}}

* Introdução
Este projeto consiste no uso de um \ac{DAC} para efetuar o desenho de figuras arbitrárias com o modo XY
do osciloscópio (ou XYZ nos analógicos). A escolha do [[https://www.microchip.com/wwwproducts/en/en541737][MCP4728]], em detrimento
do outro \ac{DAC} proposto prendeu-se ao facto de este ser mais rápido (menor tempo de asssentamento), apesar de term menor resolução: 
\SI{12}{\bit}, ao invés dos \SI{16}{\bit} do \ac{DAC} da /Texas Instruments/.

Inicialmente, a ideia era fazer um gerador de sinais com os sinais clássicos, tais como ondas
sinusoidais, quadradas e triangulares, com as propriedades ajustáveis, e ainda, caso houvesse tempo, um
gerador de sinais arbitrário, onde o utilizador pode desenhar a forma de onda que quiser.

No entanto, depois de lermos a /datasheet/ do MCP4728, vimos que o resultado não seria muito
satisfatório, uma vez que a tecnologia \ac{I2C} não é a mais indicada para este tipo de funcionalidade, e
o tempo de assentamento do \ac{DAC}, ainda que incrivelmente baixo para algumas aplicações, resultaria
numas ondas não muito suaves ou então de muito baixa frequência.

Desanimados com a impossibilidade de executar a nossa ideia inicial, lembrámo-nos de ver algumas pessoas a desenhar imagens em osciloscópios. Depois
de pensar no assunto, apercebemo-nos que seria a aplicação ideal para um projeto destes, uma vez que, no
modo XY, o tempo de assentamento era suficientemente baixo para não se notarem as transições dos saltos
em demasia.

Propusémo-nos então a fazer um sistema de desenho de animações onde o utilizador pode desenhar várias
frames de tempo regulável e ver uma representação fiel no osciloscópio do que desenhou.

* Configuração inicial
A primeira coisa que fizemos foi ler cuidadosamente a /datasheet/ correspondente ao MCP4728. Também
revimos o funcionamento do [[https://en.wikipedia.org/wiki/I%25C2%25B2C][\ac{I2C}]], que é o protocolo de comunicação usado pelo conversor.

Efetuámos a montagem cuidadosa do circuito pedido, assim como [[fig:Wiring][o seu desenho]] a computador recorrendo ao
programa [[http://fritzing.org/home/][Fritzing]], e de seguida escrevemos um programa simples que fazia uma chamada a todos os endereços
\ac{I2C} possíveis para termos a certeza que estávamos a ter uma comunicação bem sucedida com o
dispositivo.

#+NAME: fig:Wiring
#+CAPTION: Representação das ligações elétricas
[[file:Pictures/breadboard_setup.png]]

Não só descobrimos que a montagem tinha sido feita corretamente, uma vez que estávamos a receber um
\texttt{ACK} do MCP4728, mas também que o seu endereço não era o que vinha por defeito da fábrica -
\texttt{0x60} - mas sim \texttt{0x61} (este dispositivo tem os 3 \ac{LSB} de endereço configuráveis,
guardados numa EEPROM).

Verificámos na /datasheet/ que existe um comando [[id:4425274b-aab9-4c6e-a1b8-babebde948b2][General Call Read Address]], que permite obter o endereço
do \ac{DAC} sem fazer /polling/ de todos os endereços. Apesar de já não ser necessário, implementámo-lo
de qualquer maneira como desafio.

A implementação do comando [[id:4425274b-aab9-4c6e-a1b8-babebde948b2][Write \ac{I2C} Address Bits]] foi bem sucedida, conseguindo mudar o endereço
de \texttt{0x61} para \texttt{0x60}.

Usando o comando [[id:56b96a2d-1623-49f4-9d64-b22e747d8ec1][Fast Write]], conseguimos definir a tensão de um dos outputs para um valor pretendido e
definir os outros como resistências à massa.

Considerámos que nos encontrávamos na posição de iniciar o envio de pontos e visualização no
osciloscópio, no modo XY. Depois de testarmos o envio de 1 e 2 pontos com sucesso, testámos a transmissão
de uma circuferência. Para isso, utilizámos [[id:9086e8c2-73b9-4fc9-b209-bce4e496085a][estes scripts]] para gerar $100$ pontos da função $\sin$.
Desfazando X e o Y \SI{90}{\degree}, a circunferência foi desenhada com sucesso.

Inicialmente, começámos por animar o desenho ao longo do tempo, alternando entre 2 circunferências de
raios diferentes a cada \SI{5}{\second}. Depois decidimos fazer uma letra, ainda manualmente. Desenhámos no /software Inkscape/ a
letra =C=, num documento quadrado de 4096 pontos de lado, e amostrámos 20 pontos, definindo as suas
coordenadas X e Y, e escrevendo num array do programa que corria no MCU. Mais uma vez, o teste foi um
sucesso.

A partir deste ponto considerámos que já tínhamos uma base de trabalho razoável e decidimos efetuar a
medição rigorosa do tempo de envio de cada pacote, com o objetivo de que tudo o que fizessemos daqui para
a frente tomasse partido de toda a capacidade do PIC32 e do MCP4728.

* Detalhes técnicos
** TODO Comandos utilizados e configuração \acs{I2C}
*** Frequência de funcionamento
Tendo em conta que queríamos desenhar uma frame o mais rapidamente possível, acabámos por usar
\SI{1}{\mega\hertz} como frequência de \ac{I2C} (/Fast Mode Plus/). As resistências de /pull-up/ foram
alteradas para um valor adequado: \SI{4.7}{\kilo\ohm}.

Enquanto que o \ac{DAC} suportava uma frequência ainda maior (/High Speed Mode/), esta era a máxima
suportada pelo PIC32.

*** /General Call Read Address/ e /Write \acs{I2C} Address Bits/
:PROPERTIES:
:ID:       4425274b-aab9-4c6e-a1b8-babebde948b2
:END:
Estes comandos merecem atenção especial pois não consistem apenas em correr um comando.

#+NAME: fig:GeneralCallReadAddr
#+CAPTION: Diagrama do comando /General Call Read Address/, retirado da /datasheet/ do MCP4728
[[file:Pictures/generalCallReadAddr.png]]

Como podemos ver no [[fig:GeneralCallReadAddr][diagrama]] para o comando /General Call Read Address/ (e semelhantemente para o /Write
Address Bits/), é preciso que o =LDAC= tenha um \ac{FE} entre o 8\ordMas e o 9\ordMas pulso de relógio.

Obter essa \ac{FE} não foi trivial, mas depois de ler a /datasheet/ do PIC32, vimos que o bit TBF é
anulado precisamente no instante que queremos. Para conseguirmos reagir rapidamente, definimos um /timer/
de \SI{500}{\kilo\hertz} que verificava esse bit e colocava o LDAC a 0 no instante correto (como está
feito no ficheiro =AddrReadWrite.cpp=).

*** /Fast Write/
:PROPERTIES:
:ID:       56b96a2d-1623-49f4-9d64-b22e747d8ec1
:END:
Este comando permite atualizar os registos internos de *todas* as saídas do \ac{DAC}. As saídas em si são
atualizadas quando o =LDAC= é (ou passa para) 0.

Como este comando envia informação de todas as saídas (\SI{1+8}{\byte}), não foi utilizado por nós na
versão final.

*** /Multi-Write/

** TODO Temporizações
:PROPERTIES:
:ID:       f0c8fa30-7070-4227-afd7-e13092c0d150
:END:
#+NAME:   fig:Timings
#+CAPTION: Diagrama ilustrativo dos tempos de envio
[[file:Pictures/timings_diagram.png]]

Frequência \ac{I2C}, /Fast Mode Plus/ = 1Mhz
Frequência \ac{I2C} efetivamente medida = 1/(1.1us) Hz = 910kHz
Tempo de transferência de um byte + ACK = (8+1) / f = 9.5us
Pausas encontradas:
- p1, entre o endereço e os bytes de dados(significativamente maior que as pausas a seguir mencionadas): 6.9us
- p2, entre bytes+ACK (5 pausas): 2.66us
- p3, entre o 6 byte+ACK de dados e o STOP: 7.88us
- p4, entre o STOP e o posterior START do próximo envio: 8.5us
Assim, desprezando o tempo do START e STOP, o cáculo do período é dado por (7*t(byte+ack)+p1+5*p2+p3) = 95us.

A medição efetuada no osciloscópio, recorrendo aos cursores, confirmou os 95 us. Para questões de código
aproximamos este valor a 100us, dando assim uma margem para possíveis atrasados (não nos podemos esquecer
que estamos a correr várias funções).

** TODO Aplicação de controlo
Desenhar as formas manualmente, ou seja, com recurso a papel e lápis, não era viável visto que seria
extremamente trabalhoso, pelo que ponderamos duas opções para otimizar o processo:

- Opção 1 :: Desenho na grelha de um ficheiro /Excel/ e exportando para /arrays/ com o uso de macros ou
             de um programa auxiliar que lesse =.csv=

- Opção 2 :: Criação de um programa para o computador em C, com interface gráfica, para que, com auxílio
             de uma grelha, o utilizador possa desenhar a forma geométrica que quiser, sendo esta
             exportada num formato fácil de importar no programa do MCU.

Optámos pela *opção 2* uma vez que:
- Linguagem C já era familiar
- Tinha maior flexibilidade para implementar várias /features/ que tínhamos em mente
- Poderia ser extendido facilmente de maneira a fazer *comunicação direta* (série) com o PIC32 e enviar
  as animações sem recompilação ou /upload/ de programas novos

A dificuldade principal era criar um programa com interface gráfica de raiz. No entanto, como já tínhamos
investigado sobre esse tópico anteriormente, decidimos usar as bibliotecas [[https://www.glfw.org/][GLFW]] (+ [[https://github.com/raysan5/raylib/blob/master/src/rglfw.c][rglfw]] para facilitar a
compilação), [[https://github.com/skaslev/gl3w][gl3w]] e [[https://github.com/ocornut/imgui][Dear ImGui]], que facilitaram bastante esse processo, apesar de serem todas muito
/lightweight/ em comparação com as alternativas (tais como Qt ou GTK).

A aplicação de controlo, após finalizada, possui as seguintes features:
- Possibilidade de desenhar várias /frames/ graficamente e de alterar o tempo de cada frame para valores
  arbitrários.
- Possibilidade de visualizar a frame anterior, para mais fácil reprodução de uma /imagem animada/. Esta
  técnica é designada por /onion skinning/. Os pontos da frame anterior aparecem com uma cor diferente,
  mais neutra, para melhor distinção.
- Uma linha vermelha, que percorre todos os pontos pela ordem em que são desenhados, de maneira a que
  seja evidente saltos visualizados no osciloscópio. Esta funcionalidade permite prever linhas
  indesejadas.
- Possibilidade de optimizar o caminho, através do algoritmo /nearest neighbour/. Esta optimização tem
  sempre de ser averiguada visualmente pelo utilizador, visto que pode até prejudicar o caminho
  percorrido. Destina-se a tentar reduzir as linhas indesejadas resultantes de saltos.
- ...
- ...

** TODO Protocolo de comunicação com o PIC32 (sobre UART)
Antes de implementar o protocolo, verificámos a /endianess/ do computador e do PIC32. Ambos reveleram ser
/little-endian/. Para além disso, resolvemos adicionar uma cláusula de alerta para o compilador, visto
que todo o programa só está feito para funcionar quando ambas as partes usam /little-endian/.

O envio de dados em /plain text/ era uma opção demasiado dispendiosa - visto que cada carater requer a utilização de um byte,
pelo que começamos por procurar soluções mais eficientes. Deparamo-nos com este [[https://www.embeddedrelated.com/showarticle/113.php][artigo]],
que achamos muito útil. Foi ao ler este artigo que tivemos o primeiro contacto com o algoritmo /COBS/. Podemos resumir o algoritmo como cada bloco 
que termine com o delimitador escolhido é substituído por um bloco que começa com o tamanho do próprio bloco seguido dos dados, e o pacote final termina 
com o delimitador. A sequência de operações é a seguinte:
(1) Ao analisar a sequência, começamos por verificar se o primeiro valor é a /escape sequence/, inicializando o tamanho a escrever a /1/
(2) Caso não hajam mais dados a ler, escrevemos a /escape sequence/
(3) Caso seja a /escape sequence/, escrevemos logo 01 e voltamos ao passo (1)
(4) Caso não seja, incrementamos o tamanho a escrever em 1 unidades
(5) Continuamos até encontrar a /escape sequence/, e aí escrevemos o tamanho seguido da sequência de dados lida diferente da /escape sequence/
Assim, a sequência 07 09 00 01 00 00 02 03 04 05 06 00 18 22 passaria a 03 07 09 02 01 01 06 02 03 04 05 06 03 18 22 00.
No caso da nossa implementação adaptada, o valor delimitador aparece no início (e não no fim do pacote, como na implementação original do /COBS/).

* Conclusão
Este trabalho levou ao aprofundamento do nosso conhecimento em vários domínios, nomeadamente:
- Familizarização com a ferramenta git, com recurso ao Gitlab
- Domínio da linguagem LaTeX
- Familiarização com a leitura de /datasheets/
- Aprofundamento do conhecimento do microcontrolador PIC32
- Aprofundamento do conhecimento do protocolo de comunicação \ac{I2C}
- Integração de bibliotecas, mais concretamente, a biblioteca Dear ImGUI
- Aprofundamento do conhecimento de transferência de dados, assim como os seus problemas: /framing/,
  /data loss/, etc
- Desenvolvimento de protocolo de comunicação binário adaptado, baseado em /COBS/
- Aprofundamento de resolução de problemas de colisão, relativamente ao desenvolvimento do jogo /Pong/

Inicialmente tivemos algumas pequenas complicações, como a falha na leitura dos valores durante toda a
segunda aula prática laboratorial, mas rapidamente foram solucionadas. O problema mais grave foi sem
dúvida alguma termos queimado a placa fornecida pela faculdade, devido a termos ligado um transformador
que tinhamos connosco de 12V. Apesar da inscrição referente ao /jack DC/ dizer /15V MAX!/, o /jumper/
azul da placa responsável pela seleção do /Power Select/ encontrava-se no modo /Bypass/, o que, através
da nossa pesquisa, indica que o PIC32 é diretamente alimentado pela fonte ligada ao /jack DC/. Como o
PIC32 apenas suporta 6V diretamente, acreditamos que o chip queimou. Foi evidente que algo errado
aconteceu visto que o /IC3/ da placa ficou "furado". No mesmo dia adquirimos outra placa igual.

Consideramos que este trabalho, enquanto futuros engenheiros, representou um processo de aprendizagem
significativo. Tivemos a oportunidade de abordar conceitos multidisciplinares, nomeadamente de unidades
curriculares como Programação, Informação e Comunicação e, como não poderia deixar de ser, Computadores.

* Apêndices                                                                                    :ignore_nested:
#+BEGIN_EXPORT latex
\appendix
\section*{Apêndices}
\addcontentsline{toc}{section}{Apêndices}
\renewcommand{\thesubsection}{\Alph{subsection}}
#+END_EXPORT
** Criação do /array/ com os valores sinusoidais
:PROPERTIES:
:ID:       9086e8c2-73b9-4fc9-b209-bce4e496085a
:END:
O próximo excerto de código gera 100 valores da função $2048 + 2047 \sin t$, com $t \in [0, 2\pi[$, e imprime
um /array/ em linguagem C do tipo =uint16_t[]= com esses valores.
#+BEGIN_SRC matlab :results output :exports both :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 BigSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 2047*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 BigSin[] = {
         2048, 2177, 2305, 2432, 2557, 2681, 2802, 2920, 3034, 3145,
         3251, 3353, 3449, 3540, 3625, 3704, 3776, 3842, 3900, 3951,
         3995, 4031, 4059, 4079, 4091, 4095, 4091, 4079, 4059, 4031,
         3995, 3951, 3900, 3842, 3776, 3704, 3625, 3540, 3449, 3353,
         3251, 3145, 3034, 2920, 2802, 2681, 2557, 2432, 2305, 2177,
         2048, 1919, 1791, 1664, 1539, 1415, 1294, 1176, 1062, 951,
         845,  743,  647,  556,  471,  392,  320,  254,  196,  145,
         101,  65,   37,   17,   5,    1,    5,    17,   37,   65,
         101,  145,  196,  254,  320,  392,  471,  556,  647,  743,
         845,  951,  1062, 1176, 1294, 1415, 1539, 1664, 1791, 1919,
     };"
#+end_example

Usámos o mesmo processo para gerar os valores para uma sinusoidal mais pequena, com a fórmula
$2048 + 1024 \sin t$.
#+BEGIN_SRC matlab :results output :exports none :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 SmallSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 1024*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 SmallSin[] = {
         2048, 2112, 2176, 2240, 2303, 2364, 2425, 2484, 2541, 2597,
         2650, 2701, 2749, 2794, 2837, 2876, 2913, 2945, 2975, 3000,
         3022, 3040, 3054, 3064, 3070, 3072, 3070, 3064, 3054, 3040,
         3022, 3000, 2975, 2945, 2913, 2876, 2837, 2794, 2749, 2701,
         2650, 2597, 2541, 2484, 2425, 2364, 2303, 2240, 2176, 2112,
         2048, 1984, 1920, 1856, 1793, 1732, 1671, 1612, 1555, 1499,
         1446, 1395, 1347, 1302, 1259, 1220, 1183, 1151, 1121, 1096,
         1074, 1056, 1042, 1032, 1026, 1024, 1026, 1032, 1042, 1056,
         1074, 1096, 1121, 1151, 1183, 1220, 1259, 1302, 1347, 1395,
         1446, 1499, 1555, 1612, 1671, 1732, 1793, 1856, 1920, 1984,
     };"
#+end_example

** Acrónimos
#+BEGIN_EXPORT latex
\begin{acronym}
  \acro{DAC}{Digital-to-Analog Converter}
  \acro{I2C}[\texorpdfstring{I\textsuperscript{2}C}{I2C}]{Inter-Integrated Circuit}
  \acro{FE}{falling edge}
  \acro{LSB}{bits menos significativos}
\end{acronym}
#+END_EXPORT
