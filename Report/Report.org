#+TITLE: Projeto de Computadores
#+SUBTITLE: Desenho de figuras arbitrárias usando um \acs{DAC} com o modo XY
#+AUTHOR: André Aragão e Gonçalo Santos
#+LANGUAGE: pt
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage[portuguese]{babel}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[section]{placeins}
#+LATEX_HEADER: \usepackage[printonlyused]{acronym}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}}

* Introdução
Este projeto consiste no uso de um \ac{DAC} para efetuar o desenho de figuras arbitrárias com o modo XY
do osciloscópio (ou XYZ nos analógicos). Colocamos como primeira opção o MCP4728 visto que se tratava de um \ac{DAC} mais rápido (menor tempo de asssentamento) do que o outro proposto nos trabalhos, da /Texas Instruments/, apesar de termos menor resolução: 12 bits, ao invés dos 16bits do outro.

Este relatório está dividido em 2 secções principais:
- Diário de bordo :: Nesta secção apresentamos o trabalho desenvolvido e os problemas encontrados em cada
     dia de trabalho
- Detalhes técnicos :: Nesta secção são apresentados todos os detalhes técnicos do nosso projeto

* Diário de bordo
** [2018-12-14 Fri] Primeira aula prática laboratorial
Foi nesta aula que foram anunciados os projetos que tinham sido atribuídos a cada equipa, ficando a nossa
equipa com o [[https://www.microchip.com/wwwproducts/en/en541737][MCP4728]]. Assim que soubemos qual era o nosso, começámos a ler cuidadosamente a /datasheet/
correspondente. Também aproveitámos para rever o funcionamento do [[https://en.wikipedia.org/wiki/I%25C2%25B2C][\ac{I2C}]], que é o sistema de comunicação
usado pelo nosso conversor.

Ao fim de algum tempo, efetuámos a montagem cuidadosa do circuito pedido, assim como [[fig:Wiring][o seu desenho]] a
computador recorrendo ao programa [[http://fritzing.org/home/][Fritzing]]. Assim que a montagem foi aprovada pelo professor, escrevemos
um programa simples que fazia uma chamada a todos os endereços \ac{I2C} possíveis para termos a certeza
que estávamos a ter uma comunicação bem sucedida com o dispositivo.

#+NAME: fig:Wiring
#+CAPTION: Representação das ligações elétricas
[[file:Pictures/breadboard_setup.png]]

Não só descobrimos que a montagem tinha sido feita corretamente, uma vez que estávamos a receber um
\texttt{ACK} do MCP4728, mas também que o seu endereço não era o que vinha por defeito da fábrica -
\texttt{0x60} - mas sim \texttt{0x61} (este dispositivo tem os 3 \ac{LSB} de endereço configuráveis, guardados
numa EEPROM).
** TODO Trabalho em casa
Implementação do General Read Address.

** [2018-12-21 Fri] Segunda aula prática laboratorial
Neste dia, focamo-nos em tentar enviar um comando \ac{I2C} para definir uma tensão analógica numa das 4
saídas do MCP4728.

Infelizmente, passámos a maior parte da aula sem obter grande sucesso. Pensamos que o multímetro se
encontrava a efectuar medições erradas, porque, chegando a casa, e sem nenhuma modificação quer a nível
de montagem, quer a nível de código, verificámos que estava a funcionar o corretamente.

Conseguimos ainda variar a tensão entre 2 pontos pré-definidos.

** [2018-12-22 Sat] Temporizações e início de testes modo XY
O passo seguinte foi tentar enviar vários sinais consecutivos e, com recurso ao osciloscópio, efetuar a
sua medição. Aquando do upload de um programa com delay, no ciclo for, de valor igual a 1ms, verificamos
que o upload seguinte não era bem sucedido. Ainda não sabemos a causa concreta do problema. O problema
foi encontrado com uma frequência de clock de 100kHz. Posteriormente usamos 400kHz e isso já não se
verificava. Acabamos por utilizar uma frequência de 1Mhz, alterando o valor das resistências de pull-up
para um valor adequado - 4.7kOhms, valor entre 1 e 10Mhz como detalhado na datasheet para esta frequência
de relógio. A esta frequência de funcionamento designa-se /Fast Speed Plus/, e é a velocidade de
transferência máxima suportada por esta MCU.

Posteriormente iniciamos as medições de diversos tempos, abordadas em detalhe na secção de detalhes técnicos.

Iniciamos a exploração do modo XY, mais concretamente tentando o envio de um ponto, seguido do envio de 2 pontos. Ambos os testes foram um sucesso. Prosseguimos assim para a tentativa do envio de uma circuferência, recorrendo à utilização da função seno, e cosseno: utilizamos a função seno desfazada 90º, ou seja, como a função seno estava definida através de 100 pontos (100 pontos definiam 2pi), para desfazarmos 90º (pi/2), desfazamos 25 pontos. Colocamos em anexo o script MATLAB para a geração dos pontos.

** [2018-12-23 Sun] Testes extensivos modo XY e início da aplicação de controlo
Começamos por verificar que tudo estava funcional e que poderíamos prosseguir para mais testes. Visto que
tudo estava OK decidimos tirar fotos das formas de onda visualizadas no osciloscópio, assim como do modo
XY. Neste momento apenas testamos a possibilidade de enviar circunferências, de raios diferentes, com 5s
de espaçamento entre elas.

Como próximo passo decidimos começar por fazer uma letra, ainda manualmente. Desenhamos no software
Inkscape um C, num documento com 4096 pontos de comprimento e largura, e amostramos 20 pontos, definindo
as suas coordenadas X e Y. O teste foi um sucesso.

Desenhar as formas manualmente, ie, papel e lápis, não é opção visto que seria extremamente trabalhoso,
pelo que ponderamos duas opções:

Opção 1
- Desenhar numa grelha no Excel a forma que queremos
- Exportar para CSV
- Implementar um parser CSV -> C

Opção 2: Criar um programa em C, com interface gráfica, para que com auxílio de uma grelha o utilizador
possa desenhar a forma geométrica que quer e esta seja enviada via comunicação série para o pic32

Optamos pelo desenvolvimento do programa em C, e iniciamos o seu desenvolvimento. Implementamos a
interface gráfica recorrendo à biblioteca Dear ImGui, o que nos facilitou imenso o trabalho, contudo
ainda com funcionalidade reduzida: apenas é possível reproduzir uma frame, e o mapeamento dos pontos
selecionados na grelha é exportado em C, e não comunicado diretamente ao pic32 recorrendo à comunicação
série.

** [2018-12-28 Fri] Melhoramento aplicação de controlo
Este dia foi dedicado ao melhoramento da interface gráfica. Adicionamos as seguintes funcionadidades:
- Possibilidade de desenhar várias frames graficamente e de alterar o tempo de cada frame para valores arbitrários.
- Possibilidade de visualizar a frame anterior, para mais fácil reprodução de uma /imagem animada/. Esta técnica é designada por /onion skin/. Os blocos da frame anterior aparecem a cor diferente, para melhor identificação.
- Uma linha vermelha, que percorre todos os blocos, de maneira a que seja evidente saltos visualizados no osciloscópio, derivados de blocos não consecutivos. Esta funcionalidade é mais útil para osciloscópios analógicos.
- Possibilidade de optimizar o caminho, através do algoritmo /nearest neighbour/. Esta optimização tem sempre de ser averiguada visualmente pelo utilizador, visto que pode até prejudicar o caminho percorrido. Destina-se somente à optimização de saltos.

A nível de hardware mudamos os cabos para uns de tamanho adaptado, para facilidade de transporte e redução de possíveis perdas. Verificamos que estes cabos não ficavam tão bem presos aos pinos fêmea do MCU, fazendo por vezes mau contacto. Voltamos ao /setup/ inicial.

**  [2019-1-3 Thu] Implementação de modo Z e protocolo de comunicação
Começamos por tentar implementar uma maneira de eliminar as linhas visualizadas entre blocos não consecutivos. Mais uma vez referimos que esta funcionalidade só é útil para osciloscópios analógicos.
Medimos o tempo de assentamento da alteração de um valor lógico, e verificamos que o pior valor medido coincide com o valor máximo fornecido pela /datasheet/: 6.4us.
Visto que o MCP é um \ac{DAC} de 12 bits, a nossa ideia é utilizar um bit extra (13º bit) que serve para confirmar, ou não, se o modo Z se encontra ativo (responsável pela visualização das linhas entre blocos).
Associamos este bit extra ao pino 6, visto que se trata de uma saída digital, ou seja, tem um tempo de escrita bastante superior a uma saída analógica.
Verificamos que estava a funcionar como implementamos, e confirmamos as nossas suspeitas: estamos a ligar o modo Z ao mesmo tempo que desligamos o LDAC, o que significa que estamos a ativá-lo antes da mudança do valor analógico ser tomada, o que significa que a linha que queriamos eliminar vai continuar a aparecer. Pretendemos ligar o modo Z somente depois do valor analógico já ter /assentado/. Assim, teremos de recorrer a um novo timer.
Desta maneira, aquando da mudança de valor, ele desliga. Verificamos e obtivemos precisamente isso.

O passo seguinte foi definirmos o protocolo de comunicação, e, consequentemente, implementá-lo. Todo o protocolo é explicado a seguir, na secção de detalhes técnicos.



* Detalhes técnicos
** Temporização
#+NAME:   fig:Timings
#+CAPTION: Diagrama ilustrativo dos tempos de envio
[[file:Pictures/timings_diagram.png]]

Frequência \ac{I2C}, /Fast Mode Plus/ = 1Mhz
Frequência \ac{I2C} efetivamente medida = 1/(1.1us) Hz = 910kHz
Tempo de transferência de um byte + ACK = (8+1) / f = 9.5us
Pausas encontradas:
- p1, entre o endereço e os bytes de dados(significativamente maior que as pausas a seguir mencionadas): 6.9us
- p2, entre bytes+ACK (5 pausas): 2.66us
- p3, entre o 6 byte+ACK de dados e o STOP: 7.88us
- p4, entre o STOP e o posterior START do próximo envio: 8.5us
Assim, desprezando o tempo do START e STOP, o cáculo do período é dado por (7*t(byte+ack)+p1+5*p2+p3) = 95us. A medição efetuada no osciloscópio, recorrendo aos cursores, confirmou os 95 us. 
Para questões de código aproximamos este valor a 100us, dando assim uma margem para possíveis atrasados (não nos podemos esquecer que estamos a correr várias funções).

** Aplicação de controlo
** Protocolo de comunicação

* Conclusão

* Apêndices                                                                                    :ignore_nested:
#+BEGIN_EXPORT latex
\appendix
\section*{Apêndices}
\addcontentsline{toc}{section}{Apêndices}
\renewcommand{\thesubsection}{\Alph{subsection}}
#+END_EXPORT
** Criação do /array/ com os valores sinusoidais
O próximo excerto de código gera 100 valores da função $2048 + 2047 \sin t$, com $t \in [0, 2\pi[$, e imprime
um /array/ em linguagem C do tipo =uint16_t[]= com esses valores.
#+BEGIN_SRC matlab :results output :exports both :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 BigSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 2047*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 BigSin[] = {
         2048, 2177, 2305, 2432, 2557, 2681, 2802, 2920, 3034, 3145,
         3251, 3353, 3449, 3540, 3625, 3704, 3776, 3842, 3900, 3951,
         3995, 4031, 4059, 4079, 4091, 4095, 4091, 4079, 4059, 4031,
         3995, 3951, 3900, 3842, 3776, 3704, 3625, 3540, 3449, 3353,
         3251, 3145, 3034, 2920, 2802, 2681, 2557, 2432, 2305, 2177,
         2048, 1919, 1791, 1664, 1539, 1415, 1294, 1176, 1062, 951,
         845,  743,  647,  556,  471,  392,  320,  254,  196,  145,
         101,  65,   37,   17,   5,    1,    5,    17,   37,   65,
         101,  145,  196,  254,  320,  392,  471,  556,  647,  743,
         845,  951,  1062, 1176, 1294, 1415, 1539, 1664, 1791, 1919,
     };"
#+end_example

Usámos o mesmo processo para gerar os valores para uma sinusoidal mais pequena, com a fórmula
$2048 + 1024 \sin t$.
#+BEGIN_SRC matlab :results output :exports none :eval no-export
t = linspace(0, 2*pi, 101);
t = t(1:end-1);

output = "u16 SmallSin[] = {";
for i = 1 : length(t)
    if mod(i-1, 10) == 0
        output = output + newline + "    ";
    end
    output = output + sprintf("%-6s", sprintf("%d,", round(2048 + 1024*sin(t(i)))));
end
output = output + newline + "};"
#+END_SRC
#+RESULTS:
#+begin_example
output =

    "u16 SmallSin[] = {
         2048, 2112, 2176, 2240, 2303, 2364, 2425, 2484, 2541, 2597,
         2650, 2701, 2749, 2794, 2837, 2876, 2913, 2945, 2975, 3000,
         3022, 3040, 3054, 3064, 3070, 3072, 3070, 3064, 3054, 3040,
         3022, 3000, 2975, 2945, 2913, 2876, 2837, 2794, 2749, 2701,
         2650, 2597, 2541, 2484, 2425, 2364, 2303, 2240, 2176, 2112,
         2048, 1984, 1920, 1856, 1793, 1732, 1671, 1612, 1555, 1499,
         1446, 1395, 1347, 1302, 1259, 1220, 1183, 1151, 1121, 1096,
         1074, 1056, 1042, 1032, 1026, 1024, 1026, 1032, 1042, 1056,
         1074, 1096, 1121, 1151, 1183, 1220, 1259, 1302, 1347, 1395,
         1446, 1499, 1555, 1612, 1671, 1732, 1793, 1856, 1920, 1984,
     };"
#+end_example

** Acrónimos
#+BEGIN_EXPORT latex
\begin{acronym}
  \acro{DAC}{Digital-to-Analog Converter}
  \acro{I2C}[I\textsuperscript{2}C]{Inter-Integrated Circuit}
  \acro{LSB}{bits menos significativos}
\end{acronym}
#+END_EXPORT
